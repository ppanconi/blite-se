\chapter{Il linguaggio per l'orchestrazione}

\section{BPEL, lo standard per l'orchestrazione di Servizi Web}
Abbiamo visto come SOA e i Servizi Web siano una delle risposte più recenti
alla necessità di integrare funzionalità applicative eterogenee, e di fornire
un modello di sviluppo software che sia il pi\`u efficace possibile rispetto
alla natura dinamica dei domini applicativi tipici delle grandi realtà
aziendali.

Alla base della metodologia SOA vi è l'approccio ``bottom-up'', secondo cui è
possibile comporre le funzionalita di base offerte dalle diverse applicazioni
aziendali per crearne di più complesse e articolate. Gli standard e i linguaggi
dei Web Services foniscono il supporto tecnologico e formale per realizzare tale
integrazione che nella maggior parte degli scenari reali prevede di dover far
comunicare tecnolgie e formalismi del tutto eterogeni e incopatibli. Uno delle
possibilità più interessanti è quella di poter utilizzare il patrimonio storico
(``legacy'') del software azzindale tramite standard moderni e aperti, e poter
fare dialogare le applicazioni di ultima generazione con quelle più ``mature'',
che spesso mantengono un alto valore aziendale ma si basano su tecnologie e
metodologie proprietarie ormai difficilmente manutenibili.

Predisporre i componenti e renderli disponibili secondo il paradigma della
Architettura Orientata ai Servizi certo non realizza tutte le necessità di un
complesso sistema aziendale, il passo successivo non può essere che quello di
comporre le singole funzionalità di base per realizare i flussi operativi che
implemetano le reali politiche e strategie di business. Le attività aziendali
quindi possono essere rappresentate come processi (``Business Process'') che
raggruppano le singole funzionalità secondo precise regole aziendali (``Business
Rules'') e tramite primitive di aggregazione che attuano dipendeze temporali e
logiche fra i diversi componenti publicati come servizi (``Service
Orchestration''). Se si può pensare che le singole funzionalità siano i mattoni
del business e che abbiano una certa robustezza temporale, in termini di
specifica e implemetazione, i processi al contrario possono essere fortemente
dinamici e mutevoli, per poter facilmente adeguarsi alle necessità sempre nuove
che si presentano nelle attività di un'azienda.

Si capisce quindi come nasca la necessità di un formalismo specifico per la
definizione e realizzazione di tali processi. In generale si vorrebe poter
disporre di un linguaggio semplice e flessibile che possa essere utilizzato a
diversi livelli aziandali, compreso e adoperato dalle diverse figure
professionali che partecipano alla definizione e attuazione dei processi
stessi. Si vorrebbe disporre non solo di un linguaggio di programmazione
utile ai tecnici del software ma anche di un formalsmo usabile dai manager e
dagli esperti dei domini applicativi, che potese realizzare una piattaforma comune
per la collaborazione fra le diverse arie disciplinari.

E' proprio come risposta a tale necessità che si propone BPEL, un linguaggio
basato su XML per la definizione di processi aziendali realizzati come
composizione di funzionalità esposte da Servizi Web. BPEL storicamente nasce
dalla fusione di due teconlogie sviluppate indipendetemente all'inizio degli
anni 2000: WSFL (Web Service Flow Language) di IBM e XLANG di Microsoft. La
prima versione del linguaggio (BPEL4WS ``Business Process Execution Language for Web Services - Version 1.0'')
risale al 31 Luglio 2002 e fu prodotta del lavoro congiuto di grandi
aziende come IBM, BEA, SAP, Siebel e Microsoft. Dall'Aprile del 2003 il lavoro
di stesura della versione successiva (1.1) è stato affidato alla supervisione di
OASIS, società nata con il compito di realizzare standard aperti e condivisi
dalla comunità internazionale, al 5 Maggio 2003 è datato il rilascio di questa
versione nella stesura ufficiale. Oasis è  anche la curatrice della
versione 2.0 dello standard (WS-BPEL ``Web Services Business Process Execution
Language Version 2.0'') che ha visto il primo rilascio ufficiale in data
11 Aprile 2007.
\\
\ldots
\newpage

Nonostante BPEL sia ampiamente documentato da specifiche e standard ufficiali e
sia disponibile in diverse implemetazioni, le problematiche realitive al suo
uso non mancano e alcune di esse possono essere attribuite alla
mancanza di una semantica formale. Il processo di realizzazione di applicazioni BPEL
risulta difficile e fortemente soggetto ad errori anche per la presenza di
costrutti complessi come: il parallelismo, la concorrenza, la terminazione
forzata di attività, la correlazione e la compensazione, quest'ultima utilizzata
per la realizzazione di ``Long-Running Transaction'', e forse ancora non 
compresa in tutti i suoi aspetti e potenzialità dagli utilizzatori. In tal
senso si è pensato che un processo di analisi e di formalizzazione di
tali costrutti potesse essere utile sia per chi si trova ad utilizzarli sia per
coloro che ne definiscono le specifiche in linguaggio naturale, in modo tale da
renderne più chiaro e eventualmente semplificarne gli aspetti più delicati.

Un approccio, per cercare di affrontare queste problematiche, è stato quello di
utilizzare la teoria dei metodi formali e delle algebre di processo per la
definizione di una sematica formale e per la realizzazione successiva di una
piattaforma per la verifica e la dimostrazione di proprietà di applicazioni
basate su BPEL. Con tale scopo è stato creato Blite, una variante semplificata di
BPEL, che riproduce alcune delle sue funzionalità più caratteristiche cercando
d'altra parte di semplificarne alcuni aspetti ritenuti marginali nella
realizzazione del modello Process Orinted.
   
Il lavoro svolto in questa tesi è da considerarsi a supporto di questa attività,
come un ulteriore verifica e confronto del processo di astrazione teorica e
formale con gli aspetti più concreti e tecnologici legati all'implementazione di
un linguaggio come BPEL per l'orchestrazione distribuita di servizi. Infatti
l'obiettivo primario è stato quello di realizzare un'implemetazione di Blite che
potesse essere il più vicino possibile, per caratteristiche e applicabilità, ai
motori di esecuzione di BPEL attualmente disponibili. Se da un lato Blite vuole
essere un'analisi di BPEL fatta tramite un processo di astrazione e
formalizzazione, il lavoro qui esposto vuole essere a sua volta un'analisi di
tale processo, nel senso che ne vuole verificare la compatibilità e l'attinenza
con le problematiche più concrete e tecnologiche presenti nell'ambito della
orchestrazione di servizi. Di fatto quello che abbiamo fatto non è altro che un
test critico di come i costrutti formali utilizzati per fornire la semtica del
liguaggio, potessero essere realmente implementati in scenari di sowfware di
produzione, e che quindi continuassero a mantenere un legame a doppio filo con
il mondo delle tacnologia da cui hanno tratto iniziale ispirazione.
\\

Di seguito andremo a decrivere la sintassi e  la sematica originali di Blite e
le versioni leggermente modificate di cui è stata realizzata l'implementazione.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BLITE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Blite, un approccio formale a BPEL}

Come già detto Blite è un linguaggio che può essere visto come una
semplificazione di BPEL, nel senso che ne ripropone solo alcuni aspetti
essenziali come, partner links, process e activity termination, message
correlation, fault handler e compesation handler, e ne tralascia altri come
timeout, eventi, termination handler e flow graph.

Anche il modello di invocazione dei servizi è stato semplificato. In BPEL difatti
sono possibili sia invocazioni one-way che request-response. Le prime sono
invocazioni asincrone, in cui il clinet dopo aver invocato può continuare la sua
elaborazione senza dover attendere alcuna risposta, le seconde invece realizzano
invocazioni sincrone, in cui l'operazione di richiesta blocca il client fino al
sopraggiungere del risultato. In Blite è stato di fatto scelto di supportare
solamente la comunicazione asincrona, in qualto il comportamento sincrono può
essere sempre riprodotto tramite l'opprtuna sequenzializzazione di operazioni
asincrone.
% In pratica in BPEL sono presenti le tre primitive di comunicazione
% \texttt{invoke}, \texttt{receive} e \texttt{replay}, in Blite rimangono
% solamente la \texttt{invoke} e la \texttt{receive}

Anche il meccanismo di instradamento dei messaggi alle opprtune istanze di
processo è stato semplificato. In generale in BPEL tale obiettivo può essere
realizzato con due tecniche alternative: il \emph{WS-Addressing}, che guida
l'indirizzamento in base al valore di meta infomazioni
contenute negli header, e la \emph{Correlazione (Message
Correlation)} che invece discrimina rispetto ai valori applicativi contenuti in
determinate parti del corpo stesso dei messaggi. I Blite è stato scelto di
rappresentare solamente quest'ultima metodologia. 

In definitiva è stato selezionato un core di BPEL, per cui fosse abbastanza
agevole definire una sematica formale e con cui, tramite ``encoding'', fosse
possibile riproporre tutte le funzionalità del linguaggio.

La sintassi di Blite è data in Tabella \ref{tab:syntaxwsbpel}. La categoria
sintattica \emph{Servizio (Service)} rappresenta  sia la definizione di
processo $\xproc{\xsa}{\xh_f}$, che le istanze nella loro esecuzione a runtime
con uno specifico stato della memeoria, $\xinst{\xsigma}{\xs}$; quest'ultima
forma non specifica ulteriormente il linguaggio ma serve per poter introdurre
una rappresentazione della fase di esecuzione indispensabile per
poter definire la sematica operazionale.

Una definizione di servizio è semplicemente uno \emph{Scope} (o
\emph{Contesto}) in cui è definita una
\emph{Start Activity} $\xsa$ e un \emph{Fault Handler} $\xh_f$. Difatti si
impone che le attività iniziali di un processo siano un sott'insieme di tutte
quelle possibili e che in pratica la prima attività operativa (o \emph{Basic
Activity}) sia una ricezione. Le attività infatti sono divise in due categorie
principali, le \emph{Basic Activity} e le \emph{Structured activities}. Le
prime sono l'attività primitive, cioè individuano le operazioni di
base compiute da un'istanza di processo, le seconde sono una composizione
strutturale di quest'ultime. Di fatto le attività di base sono costituite
dalla invocazione asincrona $\xinv{\plinv}{\xo}{\bar{\xx}}$ di un'operazione
remota $\xo$ su un \emph{partner link} $\plinv$ con parametri attuali
$\bar{\xx}$, dall'attesa dell'invocazione $\xrec{\plrec}{\xo}{\bar{\xx}}$
dell'operazione locale $\xo$ tramite il \emph{partner link} $\plrec$ con
parametri formali ${\bar{\xx}}$, dall'assegnazione della valutazione
dell'espressione $\xe$ alla variabile $\xx$, dalla attività vuota $\xskip$,
dalla sollevazione di una eccezione $\xthr$ e dalla operazione di terminazione
d'istanza $\xexit$.

%%%%%%%%%%%%%%%%%%%%%%%% SYNTAX TABLE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[t]
\begin{small}
$$
\delimite{
\begin{array}{
@{\hspace{-1ex}}l@{\hspace{2ex}}r@{\hspace{.75ex}}l@{\!}l@{\hspace{1.5ex}}l@{\hspace{-1ex}}}
\textit{Basic activities} & \xa & ::= &
\xinv{\plinv}{\xo}{\bar{\xx}} \!\sepgr\!
\xrec{\plrec}{\xo}{\bar{\xx}} \!\sepgr\!
\xass{\xx}{\xe} & \textrm{invoke, receive, assign}\\[-.05cm]
 &  & \!\sepgr\! &
\xskip \!\sepgr\!
\xthr \!\sepgr\!
\xexit & \textrm{empty, throw, exit}\\[0.25cm]
%
\textit{Structured activities} & \xs & ::= &
\xa \!\sepgr\!
%\xif{\xx}{\xs_1}{\xs_2} \!\sepgr\!
\xif{\xe}{\xs_1}{\xs_2} \!\sepgr\!
%\xwhile{\xx}{\xs} & \textrm{basic, conditional, iteration}\\
\xwhile{\xe}{\xs} & \textrm{basic, conditional, iteration}\\[-.02cm]
& & \sepgr & \xs_1\xsucc\xs_2 \sepgr
\sum_{j \in J}\xrec{\plrec_j}{\xo_j}{\bar{\xx}_j}\recsep\xs_j &
\textrm{sequence, pick (with $\length{J} \,> 1$)}\\[-.05cm] & & \sepgr & \xs_1
\xpar\, \xs_2 \sepgr \xscopefc{\xs}{\xh_f}{\xh_c} & \textrm{parallel, scope}
\\[0.25cm]
%
\textit{Start activities} & \xsa & ::= &
\xrec{\plrec}{\xo}{\bar{\xx}} \!\sepgr\!
\sum_{j\in J}\xrec{\plrec_j}{\xo_j}{\bar{\xx}_j}\recsep\xs_j & \textrm{receive,
pick}\\[-.05cm] & & \sepgr & \xsa \xsucc \xs \!\sepgr\! \xsa_1 \xpar\, \xsa_2
\sepgr \xscopefc{\xsa}{\xh_f}{\xh_c} & \textrm{sequence, parallel,
scope}\\[0.25cm]
%
\textit{Services} & \xI & ::= &
\xproc{\xsa}{\xh_f} \sepgr
\xinst{\xsigma}{\xs} \sepgr
\xinst{\xsigma}{\xs} \xmid \xI & \textrm{definition, instance,
multiset}\\[0.25cm]
%
\textit{Deployments} & \xd & ::= &
\xeng{\xI}{\xcorr} \sepgr
\xd_1 \xspar \xd_2 &  \textrm{deployment, composition}
\end{array}
}
$$
\end{small}
  \vspace*{-1.20cm}
  \caption{La sintassi di Blite}
  \label{tab:syntaxwsbpel}
  \vspace*{-0.3cm}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%% FINE TABLE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Le attività strutturate sono costituite invece dalla scelta condizionale
$\xif{\cdot}{\cdot}{\cdot}$, dalla iterazione $\xwhile{\xe}{\xs}$, dalla
composizione sequenziale di sottoattività $\xs_1\xsucc\xs_2$, dalla scelta
esterna su un set non vuoto di possibili porte $\sum_{j \in
J}\xrec{\plrec_j}{\xo_j}{\bar{\xx}_j}\recsep\xs_j$\footnote{La scelta può
essere anche espressa tramite l'operatore binario $ \cdot + \cdot$.}, dalla
composizione parallela di attività $\xs_1\xpar\, \xs_2$ e per finire dal costrutto di scope o contesto $\xscopefc{\xs}{\xh_f}{\xh_c}$, dove ad una attività pricipale
detta \emph{Contest Activity} $\xs$ viene associato un \emph{Fault Handler}
$\xh_f$ e un \emph{Compensation Handler} $\xh_c$.

La sintassi afferma che le operazioni di comunicazione siano
definite su i partners link $\plinv$ per l'invocazione e $\plrec$ per la
recezione. Un ulteriore imposizione viene fatta sulla struttura sintattica di
tali oggetti richiedendo che essi siano tuple di uno o al massimo due elementi,
con la seguente ulteriore restrizione

$$
\begin{array}{ccc}

\plinv = \left\{ 
\begin{array}{l}
 \arr{\xu,\xp}   \\
 \arr{\xu}  
\end{array} \right.

&

\plrec = \left\{ 
\begin{array}{l}
 \arr{\xp,\xu}   \\
 \arr{\xp}  
\end{array} \right.

& \textrm{con } \xp \textrm{ staticamente noto e } \xu \textrm{
evetualemente variabile}

\end{array}
$$

Di fatto i partner link possono essere mono direzzionali $\arr{\cdot}$ o
bidirezionali $\arr{s1, s2}$. In quest'ultimo caso sottindendono una
comunicazione asincrona richiesta-risposta, secondo cui ad una invocazione sul servizio $s1$
quest'ultimo risponderà in maniera asincrona con una risposta sul servizio $s2$.
Di fatto si impone anche che i nomi dei servizi su cui si eseguono le ricezioni
siano staticamente noti\footnote{Quest'ultima imposizione rispecchia il
fatto che staticamente sono noti i contratti e fissate le
locazioni su cui essi sono disponibili; a runtime le varie istanze si possono
scambiare quest'ultima informazione, ma il modello non prevede che possano
nascere ne nuovi contratti ne nuove locazioni dove questi siano implementati.}.
Un esempio di comunicazione asincrona con i costrutti definiti da Blite è
rappresentato in Figura \ref{fig:lin:com}, dove è esplicitato il fatto che i
nomi dei servizi $s1$ e $s2$ oggetto delle invocazioni sono determinati a
runtime.

\begin{figure}[ht]
\begin{center}
  \includegraphics{linguaggio/dia/com}
   \caption[Comunicazione asincrona con Blite]{
   	\textsf{{\small Realizzazione della comunicazione asincrona
   	richiesta-risposta con i construtti della sintassi di Blite}} }
  \label{fig:lin:com}
\end{center}
\end{figure}

La composizione distribuita di diversi processi viene definata dalla categoria
sintattica \emph{Deployments}. Il termine $\xd_1 \xspar \xd_2$ rappresenta la
contemporanea escuzione di tutte le istanze ottenute dalle
definizioni presenti in $\xd_1$ con quelle di $\xd_2$. Il \emph{Deployment}
$\xeng{\xI}{\xcorr}$ è la definizione di processo $\xI$ con tutte le sue attuali
istanze a cui è stato associato il \emph{Correlation Set} $\xcorr$. Tale insime
individua fra tutte le variabili presenti nella definizione del processo quelle
che dovranno essere considerate per valutare la correlazione di un messaggio
ad una praticolare istanza. Vedremo come la semantica di Blite definisca tale
processo di attribuzione di un messaggio a una istanza e come tale
sematica sia stata implemetata del nostro engine di esecuzione.
 
In generale si impone la restrizione che un insieme di deployments sia
\emph{ben formato}, nel senso che i nomi nei partner link utilizzati per le
ricezioni non siano condivisi fra diversi deployment. In questo modo ogni
definizione di processo avrà i propri nomi di servizo univoci e dato un nome
sarà sempre possibile individuare un deployment preciso.

In seguito, nella definizione della semantica, si farà uso della notazione
$\bar{\cdot}$, per sottintendere tuple di valori o variabili, $\bar{\xx}$ può
essere considerata l'abbreviazione di $\arr{\xx_1,
\ldots, \xx_h}$ (con $h \geq 0$). L'ulteriore notazione $\tilde{\cdot}$
indicherà tuple speciali di uno o al massimo due elementi ($\tilde{\xp}$ starà
per $\arr{\xp_1, \xp_2}$ o $\arr{\xp_1}$). Inoltre l'operatore
$\xapp{\xdot}{\xdot}$ permetterà di ottenere la tupla $\arr{\xp,
\xu,\xx_1,\ldots,\xx_h}$ come concatenazione di $\arr{\xp, \xu}$ e
$\arr{\xx_1,\ldots,\xx_h}$ scrivendo $\xapp{\arr{\xp,
\xu}}{\arr{\xx_1,\ldots,\xx_h}}$.
\\

Per concludere si deve osservare come la sintassi esposta debba ancora essere 
considerata ``astratta'', in quanto non definisce tutti gli aspetti necessari
all'imlemetazione. In particolar modo non definisce i tipi dei valori
attribuibili alle variabili, ne la sintassi delle espressioni supportata, e
nemmeno esplicita la precedenza degli operatori di sequenzializzazione,
parallelismo e scelta esterna\footnote{In merito alla precedenza degli
operatori, il documento originale in cui è descritto Blite, afferma che
l'operatore di sequenza $\cdot ; \cdot$ ha precedenza
sull'operatore di parallelismo $\cdot | \cdot$, e che quest'ultimo ha precedeza
sull'operatore di scelta $\cdot + \cdot$}. Di fatto l'implemetazione da noi
realizzata fa riferimento ad una sintassi concreta che definisce in maniera
formale anche questi aspetti. In particolare vedremo come  i semplici
operatori binari siano trasformati in costrutti con 
delimitatori di blocco. In questo modo risulta più semplice
l'implementazione del parser, 
%in quanto evita la necessità di eseguire \emph{lookahead}, 
e anche la
precedenza di un attività rispetto l'altra risulta esplicitata nalla codifica stessa dei blocchi. In questo modo il codice risulta
più leggibile e più simile nella struttura sia ai tradizionali linguaggi di
programmazione che ad un linguaggio come BPEL basato su XML .
\\

Presentiamo ora la semanticha formale in termini operazionali. Le relazione
semantiche sono definite su termini che includono ulteriori
simboli e costrutti, rispetto a quelli definiti dalla sintassi di Tabella
\ref{tab:syntaxwsbpel}, allo scopo di rappresentare alcuni aspetti dinamici
dell'esecuzione. In particolare vengono introdotti:

\begin{itemize}
  \item \emph{Protected activities}, $\xprot{\xs}$, utilizzato per sostituire
  contesti falliti con i rispettivi compesation handler da eseguire in maniera
  protetta. La sematica chiarirà il significato di esecuzione protetta.
  
  \item \emph{Unsuccessful termination}, $\xstop$, utilizzato per uniformare il
  comportamento delle attività $\xexit$ e $\xthr$.
  
  \item \emph{Messages} $\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}$, utilizzato per
  rappresentare i messaggi prodotti delle attività invoke.
    
  \item \emph{Scope} in forma $\xscope{\xs'}{\xs_f}{\xs_c}{\xs_d}$,
  utilizzato per rappresentare l'evoluzione del contesto
  $\xscopefc{\xs}{\xs_f}{\xs_c}$, in cui il completamento di sottocontesti
  definiti in $\xs$ hanno prodotto l'istallazione di compensation handler
  reppresentati con $\xs_d$.
\end{itemize}

Inotre si introduce il concetto di attività \emph{short-lived} con l'intento
d'individuare un sott'insieme fra tutti i tipi di attività presenti nel
linguaggio. Vedremo che la semantica attribuirà a tali attività la proprietà di
essere immuni alla terminazione (in un certo senso queste queste attività
dovrenno essere considerate atomiche rispetto al processo di terminazione).
Tale insieme è costituito dalla seguenti attività

$$
\textrm{Attività \emph{short-lived}} : \{ \xskip, \xexit,
\xthr, \xstop, \xmsg{\tilde{\xp}}{\xo}{\bar{\xv}} \}
$$

e di seguito una generica attività short-lived sarà indicata con
il simbolo $\xsla$.
\\

La semantica dei termini Blite è definita tramite una congruenza strutturale, e
tramite due relazioni di transizione, una che descrive l'evoluzione delle
istanze in termini di operazioni interne, e una che descrive l'evoluzione del sistema
di deployment attraverso le comunicazioni. 

La \emph{Congruenza Strutturale}, identifica come equivalenti termini
sitatticamente diversi ma che intuitivamente rappresentano il medesimo
comportamento. Essa è definita come la \ldots indotta dalle uguaglianze
reppresentate in Tabella \ref{tab:congwsbpel}, dove per altro non sono
riportate le banali relazioni che escplicitano le ovvie proprietà di
commutazione e associatività per gli operatori binari.

%%%%% STRUCTURAL CONG Blite %%%%%
\begin{table}[t]
\begin{small}
$$
\delimite{
\begin{array}{c}
\xs \xpar \xskip \xequiv \xs
\qquad
\xskip\xsucc\xs \xequiv \xs\xsucc\xskip \xequiv \xs
\qquad
\xstop \xpar \xstop \xequiv \xstop
\qquad
\xstop \xsucc \xs \xequiv \xstop
\\[0.2cm]
\xprot{\xprot{\xs}} \xequiv \xprot{\xs}
\qquad
\xprot{\xsla} \xequiv \xsla
\qquad
\xprot{\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}\, \spar \xs} \xequiv \,
\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}} \, \spar \xprot{\xs}
\\[0.2cm]
\xscopefc{\xs}{\xs_f}{\xs_c} \xequiv
\xscope{\xs}{\xs_f}{\xs_c}{\xskip}
\qquad
(\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}\, \spar \xs_1)\xsucc\xs_2
\xequiv \, \xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}\, \spar
(\xs_1\xsucc\xs_2)
\\[0.2cm]
\xscope{\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}} \, \spar
\xs}{\xs_f}{\xs_c}{\xs_d} \xequiv\,
\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}\, \spar
\xscope{\xs}{\xs_f}{\xs_c}{\xs_d} \quad \textrm{if}\ \neg
\nothr{\xs}
\\[0.2cm]
\prooftree \xs \xequiv \xs' \quad \xs_f \xequiv \xs_f' \quad \xs_c
\xequiv \xs_c' \quad \xs_d \xequiv \xs_d' \justifies \
\xscope{\xs}{\xs_f}{\xs_c}{\xs_d} \xequiv\,
\xscope{\xs'}{\xs_f'}{\xs_c'}{\xs_d'}
\endprooftree
\\[0.45cm]
\hline\\[-0.2cm]
\prooftree \xsa \xequiv \xsa' \qquad \xh_f \xequiv \xh_f' \justifies
\ \xeng{\xproc{\xsa}{\xh_f}\xmid\xI}{\xcorr} \xequiv
\xeng{\xI\xmid\xproc{\xsa'}{\xh_f'}}{\xcorr}
\endprooftree
\qquad
\prooftree \xs \xequiv \xs' \justifies \
\xeng{\xinst{\xsigma}{\xs}\xmid\xI}{\xcorr} \xequiv
\xeng{\xI\xmid\xinst{\xsigma}{\xs'}}{\xcorr}
\endprooftree
\\[0.6cm]
\xd_1 \xspar \xd_2 \xequiv \xd_2 \xspar \xd_1
\qquad
(\xd_1 \xspar \xd_2)\, \xspar \xd_3 \xequiv \xd_1 \xspar (\xd_2
\xspar \xd_3)
\qquad
\xeng{\xinst{\xsigma}{\xskip}\xmid\xI}{\xcorr} \xequiv
\xeng{\xI}{\xcorr}
\\[0.2cm]
\xeng{\xinst{\xsigma}{\xstop}\xmid\xI}{\xcorr} \xequiv
\xeng{\xI}{\xcorr}
\qquad
\xeng{\xinst{\xsigma}{\xskip}}{\xcorr} \xspar \xd \xequiv \xd
\qquad
\xeng{\xinst{\xsigma}{\xstop}}{\xcorr} \xspar \xd \xequiv \xd
\end{array}
}
$$
\end{small}
  \vspace*{-1.20cm}
  \caption{Congruenza Strutturale per le attività e i deployment}
  \vspace*{-0.3cm}
  \label{tab:congwsbpel}
\end{table}
%%%%%%%%%%%%%%%%% STRUCTURAL CONG %%%%%%%%%%%%%%%

Dalla congruenza strutturale deduciamo che: l'attvità $\xskip$ agisce come
l'elemento identità sia per l'operatore di sequenza che per l'operatore di
parallelismo. La composizione parallela di più attività $\xstop$ è equivalente ad
un'unica $\xstop$, mentre la stessa $\xstop$ premessa nella sequenzializzazione
disabilita le attività successive. L'operatore di protezione $\xprot{\cdot}$
risulta idempotente e le attività short-lived sono da considerarsi implicitamente
protette, in questo modo è espressa la loro immunità alla terminazione. I
messaggi possono essere estratti dall'operatore di protezione.
All'inizio dell'esecuzione di uno scope il compensation handler istallato è da
considerarsi uguale all'attività $\xskip$. Importante è notare come la
produzione di messaggi non blocchi le attività successive, ne il completamento
di contesti a meno che nel contesto stesso non sia attivato un $\xthr$
(quest'ultimo possibilità è verificata tramite il predicato $\nothr{\xdot}$ che
verrà formalizzato più avanti). Quest'ultime equivalenze concorrono alla
definizione di un modello di comunicazione puramente ascincrono per i processi
Blite. Le equazioni rimanenti risultano particolarmente ovvie, in quanto
estendono la congruenza strutturale all'applicazione dei costrutti di scope,
deployment e composizione di deployment. Per concludere si osserva che istanze
del tipo $\xinst{\xsigma}{\xskip}$ e $\xinst{\xsigma}{\xstop}$ risultano
terminate e possono essere eliminate, equivalentemente istallazioni contenenti
solamente istanze terminate sono da considerasi terminate e possono a loro
volta essere eliminate.
\\

\begin{table}[t!]
\begin{small}
$$
\delimite{
\begin{array}{@{\hspace{-.1cm}}l@{\hspace{.3cm}}r@{\hspace{-.1cm}}}
\xinst{\xsigma}{\xinv{\plinv}{\xo}{\bar{\xx}}} \bpeltsarrow{\xtau}
\xinstnostate{\xsigma}{\,\xmsg{\xsigma(\plinv)}{\xo}{\xsigma(\bar{\xx})}}
\ \; \rulelabel{$\x{inv}$}
&
\xinstnostate{\xsigma}{\xrec{\plrec}{\xo}{\bar{\xx}}}
\bpeltsarrow{\xrecl{\plrec\,}{\,\xo\,}{\,\bar{\xx}}}
\xinstnostate{\xsigma}{\xskip} \; \; \rulelabel{$\x{rec}$}
\\
[0.2cm] \xinst{\xsigma}{\xass{\xx}{\xe}}
\bpeltsarrow{\xassl{\xx}{\xsigma(\xe)}}
\xinstnostate{\xsigma}{\xskip} \ \; \rulelabel{$\x{asg}$}
&
\xinstnostate{\xsigma}{\xthr}
\bpeltsarrow{\xthrl}
\xinstnostate{\xsigma}{\xstop}
\ \; \rulelabel{$\x{thr}$}
\\
[0.2cm] \multicolumn{2}{c}{
\xinstnostate{\xsigma}{\xexit}
\bpeltsarrow{\xexitl} \xinstnostate{\xsigma}{\xstop} \ \;
\rulelabel{$\x{term}$}
\qquad\
\xinstnostate{\xsigma}{\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}}\,
\bpeltsarrow{\xmsgl{\tilde{\xp}\,}{\,\xo\,}{\,\bar{\xv}}}
\xinstnostate{\xsigma}{\xskip} \ \; \rulelabel{$\x{msg}$}
\qquad\
\prooftree \xinst{\xsigma}{\xs} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs'} \justifies \
\xinst{\xsigma}{\xprot{\xs}} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xprot{\xs'}} \using \;
\rulelabel{$\x{prot}$}
\endprooftree
}
\\[0.2cm]
\multicolumn{2}{c}{
\prooftree \xinst{\xsigma}{\xs_1}
\bpeltsarrow{\xalpha} \xinstnostate{\xsigma'}{\xs_1'} \justifies \
\xinst{\xsigma}{\xs_1\xsucc\xs_2} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs_1'\xsucc\xs_2} \using \;
\rulelabel{$\x{seq}$}
\endprooftree
\qquad\qquad\quad\
\xinstnostate{\xsigma}{$ $ \sum_{j\in
J}\xrec{\plrec_j}{\xo_j}{\bar{\xx}_j}\recsep\xs_j $ $}
\bpeltsarrow{\xrecl{\plrec_h\,}{\,\xo_h\,}{\,\bar{\xx}_h}}
\xinstnostate{\xsigma}{\xs_h} \ \ \ (h \in J) \ \
\rulelabel{$\xsuml$} }
\\[0.6cm]
%\prooftree
%\xs = \left\{\begin{array}{l@{\hspace{2ex}}l}
%\xs_1 & \textrm{if}\ \xsigma(\xx) = \xtrue\\
%\xs_2 & \textrm{if}\ \xsigma(\xx) = \xfalse\\
%\end{array}\right.
%\justifies \
%\xinst{\xsigma}{\xif{\xx}{\xs_1}{\xs_2}}
%\bpeltsarrow{\xtau}
%\xinstnostate{\xsigma}{\xs}
%\using \; \rulelabel{$\x{if}$}
%\endprooftree
\prooftree \xs = \left\{\begin{array}{l@{\hspace{2ex}}l}
\\[-.60cm]
\xs_1 & \textrm{if}\ \xsigma(\xe) = \xtrue\\[-.15cm]
\xs_2 & \textrm{if}\ \xsigma(\xe) = \xfalse\\
\end{array}\right.
\justifies \
\xinst{\xsigma}{\xif{\xe}{\xs_1}{\xs_2}}
\bpeltsarrow{\xtau}
\xinstnostate{\xsigma}{\xs}
\using \; \rulelabel{$\x{if}$}
\endprooftree
&
%\prooftree \xs' = \left\{\begin{array}{l@{\hspace{2ex}}l}
%\xs\xsucc\xwhile{\xx}{\xs} &
%\textrm{if}\ \xsigma(\xx) = \xtrue\\
%\xskip & \textrm{if}\ \xsigma(\xx) = \xfalse\\
%\end{array}\right.
%\justifies \
%\xinst{\xsigma}{\xwhile{\xx}{\xs}}
%\bpeltsarrow{\xtau}
%\xinstnostate{\xsigma}{\xs'}
%\using \; \rulelabel{$\x{while}$}
%\endprooftree
\prooftree \xs' = \left\{\begin{array}{l@{\hspace{2ex}}l}
\\[-.60cm]
\xs\xsucc\xwhile{\xe}{\xs} &
\textrm{if}\ \xsigma(\xe) = \xtrue\\[-.15cm]
\xskip & \textrm{if}\ \xsigma(\xe) = \xfalse\\
\end{array}\right.
\justifies \
\xinst{\xsigma}{\xwhile{\xe}{\xs}}
\bpeltsarrow{\xtau}
\xinstnostate{\xsigma}{\xs'}
\using \; \rulelabel{$\x{while}$}
\endprooftree
\\[0.80cm]
\multicolumn{2}{c}{
\prooftree
\xinst{\xsigma}{\xs_1}
\bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs_1'}
\quad
\xalpha \notin \{\xexitl, \xthrl\}
\quad
\neg (\nothr{\xs_2}\! \vee\, \noexit{\xs_2})
\justifies \
\xinst{\xsigma}{\xs_1 \xpar \xs_2}
\bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs_1' \xpar \xs_2}
\using \; \rulelabel{$\x{par}_1$}
\endprooftree
\quad\
\prooftree
\xinstnostate{\xsigma}{\xs_1}
\bpeltsarrow{\xalpha}
\xinstnostate{\xsigma}{\xs_1'}
\quad
\xalpha \in \{\xexitl, \xthrl\}
\justifies \
\xinstnostate{\xsigma}{\xs_1 \xpar \xs_2}
\bpeltsarrow{\xalpha}
\xinstnostate{\xsigma}{\xs_1' \xpar \xhalt{\xs_2}}
\using \; \rulelabel{$\x{par}_2$}
\endprooftree
}
\\[0.7cm]
\xinstnostate{\xsigma}{\xscope{\xskip}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xdonel{\xs_c}}
\xinstnostate{\xsigma}{\xskip} \; \; \rulelabel{$\xdl_1$}
&
\xinstnostate{\xsigma}{\xscope{\xstop}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xtau} \xinstnostate{\xsigma}{\xprot{\xs_d\xsucc\xs_f}}
\; \;  \rulelabel{$\xdl_2$}
\\[0.2cm]
\multicolumn{2}{c}{
\prooftree \xinst{\xsigma}{\xs} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs'} \quad \xalpha \notin \{\xthrl,\xdonel{\xs''}\}
\justifies
\ \xinst{\xsigma}{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{ \xscope{\xs'}{\xs_f}{\xs_c}{\xs_d}}
\using \; \rulelabel{$\x{exec}$}
\endprooftree
}
\\[0.5cm]
\multicolumn{2}{c}{
\prooftree
\xinstnostate{\xsigma}{\xs}
\bpeltsarrow{\xdonel{\xs''}}
\xinstnostate{\xsigma}{\xs'}
\justifies \
\xinstnostate{\xsigma}{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xtau}
\xinstnostate{\xsigma}{\xscope{\xs'}{\xs_f}{\xs_c}{\xs''\xsucc\xs_d}}
\using \; \rulelabel{$\xdl_3$}
\endprooftree
}
\\[0.5cm]
\multicolumn{2}{c}{
\prooftree
\xinstnostate{\xsigma}{\xs} \bpeltsarrow{\xthrl}
\xinstnostate{\xsigma}{\xs'} \justifies \
\xinstnostate{\xsigma}{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xtau}
\xinstnostate{\xsigma}{\xscope{\xs'}{\xs_f}{\xs_c}{\xs_d}} \using \;
\rulelabel{$\x{fault}$}
\endprooftree
}
\end{array}
}
$$
\end{small}
  \vspace*{-1.20cm}
  \caption{Semantica operazionale per le attività.}
  \label{tab:allSOS}
  \vspace*{-0.3cm}
\end{table}

L'evoluzione delle attività di una istanza di processo è descritta dalla
relazione di transizione etichettata $\bpeltsarrow{\xalpha}$ presentata in
Tabella \ref{tab:allSOS} e dove le etichette o azioni $\xalpha$ sono generate dalla
seguente grammatica:

$$
\begin{array}
{r@{\hspace*{.3cm}}c@{\hspace*{.3cm}}l}
\xalpha & ::= &
\xtau \sepgr
\xassl{\xx}{\xv} \sepgr
\xinvl{\tilde{\xp}}{\xo}{\bar{\xv}} \sepgr
\xrecl{\plrec}{\xo}{\bar{\xx}} \sepgr
\xexitl \sepgr \xthrl \sepgr \xdonel{\xs}
\end{array}
$$

in cui i nuovi simboli introdotti devono essere interpretati come le seguenti
azioni:

\begin{itemize}
  \item $\xtau$ indica la produzione di un messaggio o operazioni interne come
  la valutazione di test nella scelta condizionata e nella iterazione
  o istallazione/attivazione di compesation handler.
  \item $\xassl{\xx}{\xv}$ indica l'assegnamento del valore $\xv$ alla
  variabile $\xx$.
  \item $\xinvl{\tilde{\xp}}{\xo}{\bar{\xv}}$ e
  $\xrecl{\plrec}{\xo}{\bar{\xx}}$  indicano rispettivamente l'esecuzione di
  una invocazione sull'operazione $\xo$, con il partner link valorizzato a
  $\tilde{\xp}$ e parametri attuali $\bar{\xv}$, e la ricezione sull'operazione
  $\xo$, partner link $\plrec$ e parametri formali $\bar{\xx}$.
  \item $\xexitl$ indica la richiesta di una terminazione forzata di una
  istanza di processo.
  \item $\xthrl$ indica la generazione di una eccezione.
  \item $\xdonel{\xs}$ indica il completamento con successo di un scopo
  che potrà essere eventualmente compesato tramite l'attività $\xs$.
\end{itemize}

La relazione $\bpeltsarrow{\xalpha}$ è definita con l'ausilio della funzione di
stato $\xsigma$ che associa un possibile valore ad ogni variabile dell'istanza,
in particolare $\xsigma(\xx)$ restituisce il valore della variabile $\xx$ sullo
stato $\xsigma$ e $\xsigma(\xe)$ restituisce il risultato della
valutazione dell'espressione $\xe$. Bisogna osservare che in alcune produzioni di
Tabella \ref{tab:allSOS} tale funzione non è esplicitata, per esempio per
semplicità si è scritto $\xinstnostate{\xsigma}{\xs}
\bpeltsarrow{\xalpha} \xinstnostate{\xsigma}{\xs'}$ invece di $\xinst{\xsigma}{\xs} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma}{\xs'}$.

Alcune funzione e predicati ausiliari, come già precedentemente osservato, sono
stati introdotti a supporto della definizione semantica. In particolare i
predicati $\noexit{\xs}$ and $\nothr{\xs}$ valutano la capacità di 
$\xs$ di eseguire $\xexit$ o $\xthr$, rispettivamente. Essi sono definiti per
induzione sulla struttura sintattica delle attività e di fatto agiscono come un
??omomorfismo?? (?? qual'è la struttura algebrica d'arrivo??), tranne che per la
scelta condizionata e l'iterazione per cui non valgono e per i casi seguenti in cui si ha:

$$
\begin{array}{c}
\noexit{\xexit}
\quad\ \
\nothr{\xthr}
\quad\ \
\prooftree
\noexit{\xs_1}
\justifies \
\noexit{\xs_1 \xsucc \xs_2}
\endprooftree
\qquad
\prooftree
\nothr{\xs_1}
\justifies \
\nothr{\xs_1 \xsucc \xs_2}
\endprooftree
\qquad
\prooftree
\noexit{\xs}
\justifies \
\noexit{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}}
\endprooftree
\end{array}
$$

Per rappresentare la semantica della terminazione viene introdotta la
funzione $\xhalt{\xdot}$, che applicata ad un'attività, la restituisce
in modo da lasciare solamente le attività short-lived e quelle protette. Anche
tale funzione è definita sulla struttura sintattica delle attvità e si ha che 
$\forall \xs \; \xhalt{\xs} = \xstop$ tranne i seguenti casi
 
$$
\begin{array}{c}
\xhalt{\xsla}=\xsla
\qquad \quad \
\xhalt{\xprot{\xs}}=\xprot{\xs}
\qquad \quad \
\xhalt{\xs_1\xsucc\xs_2}  = \xhalt{\xs_1}
\\[0.2cm]
\xhalt{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}} = \xscope{\xhalt{\xs}}{\xs_f}{\xs_c}{\xs_d}
\quad
\xhalt{ \xs' \xpar \xs'' } =  \xhalt{\xs'} \xpar \xhalt{\xs''}  
\end{array}
$$
in cui $\xs_1$ non può essere congruente a $\xskip$ o a
$\xmsg{\tilde{\xp}}{\xo}{\bar{\xv}}$, o alla composizione parallela
di essi.
\\

Commentiamo ora le regole di Tabella \ref{tab:allSOS}.
\begin{description}
  \item[\rulelabel{$\x{inv}$} \rulelabel{$\x{asg}$}] 
  Affermano che le attività di invocazione e di assegnamento
  possono procedere solamente se i loro argomenti sono espressioni
  chiuse (cioè senza varibili non inizializzate). Inoltre \rulelabel{$\x{inv}$} insieme 
  alla successiva \rulelabel{$\x{msg}$} e alla congruenza strutturale
  definisce la sematica asincrona per la comunicazione.
   
  \item[\rulelabel{$\x{rec}$}] Una operazione di ricezione offre la
  possibilità  di invocazione di un operazione locale su un fissato pertner
  link. Da osservare che a differenza della invocazione la ricezione blocca le
  attività sequenzialmente successive.
  
  \item[\rulelabel{$\x{thr}$} \rulelabel{$\x{term}$}] Rappresentono
  rispettivamente la produzione di un'eccezione e di una richiesta di
  terminazione per l'istanza corrente.
  
  \item[\rulelabel{$\x{msg}$}] Un messaggio può essere consumato
  indipendentemente dalla sua generazione.
  
  \item[\rulelabel{$\x{prot}$}] Il costrutto $\xprot{\xs}$ permette la
  normale esecuzione di $\xs$ al suo interno. Tramite la precedente relazione
  $\xhalt{\xprot{\xs}}=\xprot{\xs}$ si ottiene la protezione di $\xs$
  dalle richieste esterne di terminazione.
 
  \item[\rulelabel{$\x{seq}$} \rulelabel{$\x{pick}$} \rulelabel{$\x{if}$}
  \rulelabel{$\x{while}$}] Esprimono una sematica standard rispetto ai
  tradizionali linguaggi di programmazione e alle più comuni algebre di
  processo che prevedono l'operatore di scelta esterna.
  
  
  \item[\rulelabel{$\x{par}_1$} \rulelabel{$\x{par}_2$}] Esprimono la semantica
  caratteristica di BPEL riguardo alla terminazione nella composizione
  parallela con attività fallite. Di fatto esse affermano che l'eseguzione di
  attività parallele evolve come atteso se nessuna di esse ha sollevvato un
  eccezione o richiesto una terminazione. Viceversa se questo accade tutti i
  rami della composizione parallela vengono terminati. Si rocordi anche che
  abbiamo imposto $\xhalt{ \xs' \xpar \xs'' } =  \xhalt{\xs'} \xpar
  \xhalt{\xs''}$.
  
  \item[\rulelabel{$\xdl_1$} \rulelabel{$\xdl_3$}] Esprimono la carattersitica
  di BPEL secondo cui contesti completati con successo istallano nei rispettivi
  contesti padre i loro compensation handler per un eventuale successiva
  compensazione. Il contesto padre colleziona in sequenza i compensation halder
  di contesti figli completati (\rulelabel{$\xdl_3$}). Questa
  semantica, differentemente dalla specifica informale di BPEL, prevede che i
  compesation handler siano mantenuti attraverso un solo grado di parentela
  nella gerarchia dei contesti. Di fatti un contesto completato istalla nel suo
  padre solo il suo conpensation handler e non quelli istallati dai suoi figli.
  Una semantica alternativa poteva essere:
  $$
  \xinstnostate{\xsigma}{\xscope{\xskip}{\xs_f}{\xs_c}{\xs_d}}
\bpeltsarrow{\xdonel{\xs_d;\xs_c}}
\xinstnostate{\xsigma}{\xskip} 
  $$
  in cui si mantengono i conpensation handler precedentemente istallati.

  \item[\rulelabel{$\x{exec}$}] Se non si producono eccezioni l'esecuzione
  interna ad uno scope procede come atteso. Da osservare che questa regola è da
  applicare anche nel caso in cui $\xs$ richieda una terminazione 
  (${\xs} \bpeltsarrow{\xexitl} \xs' \bpeltsarrow{} \ldots {\xstop}$); qui a
  differenza di \rulelabel{$\x{fault}$} l'azione $\xexitl$ viene propagata anche al difuori
  del contesto per produrre la terminazione di tutta l'istanza e successivamente
  tramite l'applicazione di \rulelabel{$\xdl_2$} vengono eseguiti i
  compesation handler istallati e il fault hadler del contesto attuale.
  
  \item[\rulelabel{$\xdl_2$}] In uno scope in cui la contest activity giunge a 
  $\xstop$ a causa di una eccezione o di una richiesta di terminazione,
  attraverso un transizione interna si attiva l'esecuzione protetta dei
  compensation handler istallati e del fault handler. Importante è osservare
  come l'esecuzione dell'ambiente protetto avvenga nello stato attuale
  dell'istanza.
  
  \item[\rulelabel{$\x{fault}$}] La sollevazione di un'eccezione in $\xs$ non
  viene propagata al di fuori dello scope, ma gestita tramite una transizione
  interna.  La successiva evoluzione di ${\xs} \bpeltsarrow{\xthrl} \xs'
  \bpeltsarrow{} \ldots \, {\xstop}$ in cui vengono terminati gli eventuali
  rami paralleli, porterà all'applicazione di \rulelabel{$\xdl_2$}. 
\end{description}

Abbiamo definito il comportamento delle attività interne delle istanze di
processo, vediamo ora come avviene la creazione di tali istanze e la
comunicazione in sistemi di deployment. Il comportamento di quest'utlimi è
definito dalla realzione di riduzione $\bpelredarrow{}$ presetata in Tabella
\ref{tab:deploySOS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RIDUZIONE PER I deployment
\begin{table}[t]
\begin{small}
$$
\delimite{
\begin{array}{c}
\prooftree
\xinstnostate{\xsigma_1}{\xs_1} \bpeltsarrow{\ialpha_1}
\xinstnostate{\xsigma_1}{\xs_1'} \quad
\xinstnostate{\xsigma_2}{\xs_2} \bpeltsarrow{\oalpha_2}
\xinstnostate{\xsigma_2}{\xs_2'}
\quad \xxnewmatch{\xcorr_1}{\xsigma_1}{\talpha_1}{\talpha_2} =
\xsigma_1' \quad \neg\,
(\,\xnoCONF{\xcorr_1}{\xinst{\xsigma_1}{\xs_1} \xmid \xI_1}
{\talpha_2}{\length{\,\xsigma_1'}}\!)
\justifies \ \xeng{\xinst{\xsigma_1}{\xs_1}\xmid\xI_1}{\xcorr_1}
\xspar \xeng{\xinst{\xsigma_2}{\xs_2}\xmid\xI_2}{\xcorr_2}
\bpelredarrow{} \xeng{\xinst{\xsigma_1 \xupd
\xsigma_1'}{\xs_1'}\xmid\xI_1}{\xcorr_1} \xspar
\xeng{\xinst{\xsigma_2}{\xs'_2}\xmid\xI_2}{\xcorr_2} \using \;
\rulelabel{$\x{com}$}
\endprooftree
\\
\\
\prooftree
\xinstnostate{\emptyset}{\xscopefc{\xsa}{\xh_f}{\xskip}}
\bpeltsarrow{\ialpha_1} \xinstnostate{\emptyset}{\xs_1} \quad
\xinstnostate{\xsigma_2}{\xs_2} \bpeltsarrow{\oalpha_2}
\xinstnostate{\xsigma_2}{\xs_2'} \quad
\xxnewmatch{\xcorr_1}{\emptyset}{\talpha_1}{\talpha_2} = \xsigma_1
\!\! \quad \neg\,
(\xnoCONF{\xcorr_1}{\xI_1}{\talpha_2}{\length{\,\xsigma_1}}\!)
\justifies \ \xeng{\xproc{\xsa}{\xh_f} \xmid \xI_1}{\xcorr_1} \xspar
\xeng{\xinst{\xsigma_2}{\xs_2} \xmid  \xI_2}{\xcorr_2}
\bpelredarrow{} \xeng{\xinst{\xsigma_1}{\xs_1} \xmid
\xproc{\xsa}{\xh_f} \xmid \xI_1}{\xcorr_1} \xspar
\xeng{\xinst{\xsigma_2}{\xs_2'} \xmid \xI_2}{\xcorr_2} \using \;
\rulelabel{$\x{new}$}
\endprooftree
\\
\\
\prooftree \xinst{\xsigma}{\xs} \bpeltsarrow{\xassl{\xx}{\xv}}
\xinstnostate{\xsigma}{\xs'} \quad
\xxnewmatch{\xcorr}{\xsigma}{\xx}{\xv} = \xsigma' \justifies \
\xeng{\xinst{\xsigma}{\xs} \xmid \xI}{\xcorr} \bpelredarrow{}
\xeng{\xinst{\xsigma \xupd \xsigma'}{\xs'} \xmid \xI}{\xcorr} \using
\; \rulelabel{$\x{var}$}
\endprooftree
\qquad\qquad
\prooftree \xd_1 \bpelredarrow{} \xd_1' \justifies \ \xd_1 \xspar
\xd_2 \bpelredarrow{} \xd_1' \xspar \xd_2 \using \;
\rulelabel{$\x{part}$}
\endprooftree
\\
\\
\prooftree \xinst{\xsigma}{\xs} \bpeltsarrow{\xalpha}
\xinstnostate{\xsigma'}{\xs'} \quad \xalpha \notin\{
\ialpha_1,\, \oalpha_2,\, \xassl{\xx}{\xv} \} \justifies \
\xeng{\xinst{\xsigma}{\xs} \xmid \xI}{\xcorr} \bpelredarrow{}
\xeng{\xinst{\xsigma}{\xs'} \xmid \xI}{\xcorr} \using \;
\rulelabel{$\x{enab}$}
\endprooftree
\qquad\qquad
\prooftree \xd \xequiv \xd_1 \quad \xd_1 \bpelredarrow{} \xd_2 \quad
\xd_2 \xequiv \xd' \justifies \ \xd \bpelredarrow{} \xd' \using \;
\rulelabel{$\x{cong}$}
\endprooftree
\end{array}
}
$$
\end{small}
  \vspace*{-1.20cm}
  \caption[Regole di riduzione per deployment]{Regole di riduzione per i
  deployment (si consideri $\talpha_1 = \xapp{\plrec}{\xapp{\xo}{\bar{\xx}}}$ e 
  \mbox{$\talpha_2 =
  \xapp{\tilde{\xp}}{\xapp{\xo}{\bar{\xv}}}$}).}
  \label{tab:deploySOS}
  \vspace*{-0.3cm}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La problematica fondamentale è quella di individuare fra le varie istanze di un
deployment quella predisposta alla ricezione di un messaggio, o capiere se il
sopraggiungere di un messaggio debba causare la creazione di una nuova istanza.

Nella difinizione originale Blite è stato scelto un approccio puramente
semantico, nel senso che ne la sitassi ne la struttura dei messaggi prevedono la presenza di
informazioni aggiuntive che possono essere utilizzate per guidare tali scelte.

Di fatto si è scelto di definire un ordinamento fra tutte le istanze di
processo che concorrono alla ricezione di un messaggio e di dare la possibilità
di consumarlo solo alla prime istanze dell'ordinamento. Importante è
capire come tale ordinamento possa individuare più di un'istanza destinataria
del messaggio, in questo caso la semantica non specifica ulteriormente la scelta
e lascia indetrminismo nel comportamento.

In maniera informale l'ordinamento si basa sul seguente ragionamento: ``i
messaggi, che giungono alla porte di una definizione di processo, possono,
tramite i parametri formali, aggiungere più o meno informazione nello stato delle
istanze. Un messaggio costituito dalla tupla $\arr{\xv_1, \ldots, \xv_n}$ letto
con in paramtri formali $\arr{\xx_1, \ldots, \xx_n}$ può avere un \emph{grado di
definizione} $k \; (k \le n)$, se definisce o redifinisce con nuovi valori
esattamente $k$ variabili formali e ne lascia immutato lo stato delle restanti $n
- k$. Quindi un messaggio verrà consumato solamente da una fra le instanze con
grado di definizione minimo''. Insieme a questa regola si impone il vicolo
generale che l'assegnamento ad un variabile inclusa nel correlation set possa
essere fatto un'unica volta, cioè che non sia possibile assegnare un valore
diverso ad una variabile del correlation già precedetemente velorizzata. Se
ne conclude che non sia possibile leggere un messaggio che porterebbe un valore
diverso su una varibile di correlazione già precedentemente inizializzata.

Questi ragionamenti vengono formalizzati nella seguente funzione
$\xxnewmatch{\xcorr}{\xsigma}{\bar{\xx}}{\bar{\xv}}$, che prende un correlation
set $\xcorr$, una funzine di stato $\xsigma$, una tupla di variabili $\xx$ e un tupla di valori
$\xv$ e restituisce una funzione di stato eventualmente anche vuota
su un sottoinsieme delle variabili di $\xx$:

$$
\begin{array}{c}
\xxnewmatch{\xcorr}{\xsigma}{\xx}{\xv} =
\left\{
\begin{array}{l@{\hspace{2ex}}l}
\\[-.50cm]
\updat{\xx}{\xv} & \textrm{if}\ \xx \notin \xcorr \vee ( \xx \in \xcorr\ \wedge
\xx \notin \xdom{\xsigma})
\\[-.05cm] \emptyset & \textrm{if}\ \xx \in \xcorr
\wedge \updat{\xx}{\xv} \in \xsigma \\
\end{array}
\right.
\\[.7cm]
%\xxnewmatch{\xcorr}{\xsigma}{\xv}{\xv} =
%\emptyset \qquad
\xxnewmatch{\xcorr}{\xsigma}{\arr{}}{\arr{}} =
\emptyset
\\[.7cm]
\prooftree
\xxnewmatch{\xcorr}{\xsigma}{\xx_1}{\xv_1} = \xsigma'
\quad
\xxnewmatch{\xcorr}{\xsigma}{\bar{\xx}_2}{\bar{\xv}_2} = \xsigma''
\justifies \
\xxnewmatch{\xcorr}{\xsigma}{(\xx_1,\bar{\xx}_2)}{(\xv_1,\bar{\xv}_2)} =
\xsigma' \xupd \xsigma''
\endprooftree
\\[.7cm]
\end{array}
$$
Si oasservi come $\xxnewmatch{\xcorr}{\xsigma}{\bar{\xx}}{\bar{\xv}}$ non sia
definita nel caso in cui le tuple $\bar{\xx}$ e $\bar{\xv}$ abbiamo diversa
lunghezza e quando si abbia per un qualche $i$ che $\xx_i \in \xcorr$ e
$\updat{\xx_i}{\xv'} \in \xsigma$ con $\xv' \neq \xv_i$. 
Quest'ultimo fatto impone quanto precedentemente detto che un istanza non possa
ricevere messaggi i cui valori assegnati alle variabili attuali non siano
compatibili con lo stato del correleation set.

\begin{table}[t!]
\begin{small}
$$
\delimite{
\begin{array}{c}
% \begin{array}{@{\hspace{-.2cm}}l@{\hspace{.5cm}}l@{\hspace{-.4cm}}}
% \xxnewmatch{\xcorr}{\xsigma}{\xv}{\xv} =
% \emptyset
% &
% \xxnewmatch{\xcorr}{\xsigma}{\xx}{\xv} =
% \left\{
% \begin{array}{l@{\hspace{2ex}}l}
% \\[-.50cm]
% \updat{\xx}{\xv} & \textrm{if}\ \xx \notin \xcorr \vee ( \xx \in \xcorr\ \wedge
% \xx \notin \xdom{\xsigma})
% \\[-.05cm] \emptyset & \textrm{if}\ \xx \in \xcorr
% \wedge \updat{\xx}{\xv} \in \xsigma \\
% \end{array}
% \right.
% \\[.7cm]
% \xxnewmatch{\xcorr}{\xsigma}{\arr{}}{\arr{}} =
% \emptyset
% &
% \prooftree
% \xxnewmatch{\xcorr}{\xsigma}{\xw_1}{\xv_1} = \xsigma'
% \quad
% \xxnewmatch{\xcorr}{\xsigma}{\bar{\xw}_2}{\bar{\xv}_2} = \xsigma''
% \justifies \
% \xxnewmatch{\xcorr}{\xsigma}{(\xw_1,\bar{\xw}_2)}{(\xv_1,\bar{\xv}_2)} =
% \xsigma' \xupd \xsigma''
% \endprooftree
% \end{array}
% \vspace{.3cm}\\
%
%\begin{array}{c}
%\xxnewmatch{\xcorr}{\xsigma}{\xx}{\xv} =
%\left\{
%\begin{array}{l@{\hspace{2ex}}l}
%\updat{\xx}{\xv} & \textrm{if}\ \xx \notin \xcorr \vee ( \xx \in \xcorr\ \wedge \xx \notin \xdom{\xsigma})\\
%\emptyset & \textrm{if}\ \xx \in \xcorr \wedge \updat{\xx}{\xv} \in \xsigma \\
%\end{array}
%\right.
%\\[.5cm]
%\xxnewmatch{\xcorr}{\xsigma}{\xv}{\xv} =
%\emptyset
%\qquad\ \
%\prooftree
%\xxnewmatch{\xcorr}{\xsigma}{\xw_1}{\xv_1} = \xsigma'
%\quad
%\xxnewmatch{\xcorr}{\xsigma}{\bar{\xw}_2}{\bar{\xv}_2} = \xsigma''
%\justifies \
%\xxnewmatch{\xcorr}{\xsigma}{(\xw_1,\bar{\xw}_2)}{(\xv_1,\bar{\xv}_2)} =
%\xsigma' \xupd \xsigma''
%\endprooftree
%\vspace{.3cm}\\
%
%\hline\\
\prooftree
\length{\xxnewmatch{\xcorr}{\xsigma}{\xapp{\plrec}{\xapp{\xo}{\bar{\xx}}}}{\xapp{\tilde{\xp}}{\xapp{\xo}{\bar{\xv}}}}} < \xnum
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xrec{\plrec}{\xo}{\bar{\xx}}\recsep\xs}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\qquad\,\,
\prooftree
\exists\, h \in J \, . \,
\length{\xxnewmatch{\xcorr}{\xsigma}{\xapp{\plrec_h}{\xapp{\xo_h}{\bar{\xx}_h}}}{\xapp{\tilde{\xp}}{\xapp{\xo}{\bar{\xv}}}}} < \xnum
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{$ $  \sum_{j \in J}\xrec{\plrec_j}{\xo_j}{\bar{\xx}_j}\recsep\xs_j $ $}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\\[0.6cm]
\prooftree
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs_1}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs_1\xsucc\xs_2}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\hspace{3cm}
\prooftree
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs_1}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\ \vee\
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs_2}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs_1 \xpar \xs_2}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\\[0.6cm]
\prooftree
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xprot{\xs}}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\qquad \quad\,\,
\prooftree
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xscope{\xs}{\xs_f}{\xs_c}{\xs_d}}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\qquad \quad\,\,
\prooftree
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs}}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\ \vee\
\xnoCONF{\xcorr}{\xI}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\justifies \
\xnoCONF{\xcorr}{\xinst{\xsigma}{\xs} \xmid \xI}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}
\endprooftree
\end{array}
}
$$
\end{small}
  \vspace*{-1.20cm}
  \caption[Definizione predicato match di ricezione]{Definizione del predicato
  $\xnoCONF{\xcorr}{\xI}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}$. C'è un'attività di ricezione attiva sul partner link $\tilde{\xp}$ e
  operazione $\xo$ che può essere i match con i valori del
  messaggio $\bar{\xv}$?}
  \label{tab:barbeRec}
  \vspace*{-.3cm}
\end{table}

Con la funzione  $\xxnewmatch{\cdot}{\cdot}{\cdot}{\cdot}$ è
possibile definire il predicato
$\xnoCONF{\xcorr}{\xI}{\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}}{\xnum}$,
che valuta se un'instanza di processo $\xI$ con correlation set $\xcorr$ abbia
una attività di ricezione attiva che possa ricevere il messaggio
$\xapp{\tilde{\xp}\,}{\xapp{\,\xo\,}{\,\bar{\xv}}}$ con un grado di definizione
minore di $n$. In Tabella \ref{tab:barbeRec} tale predicato viene definito
induttivamente sulla struttura sintattica di $\xI$

A questo punto il comportamento descritto dalle regole di Tabella
\ref{tab:deploySOS}, risulta abbastanza intuitivo e può essere sintetizzato nel
seguente modo:

\begin{description}
\item[\rulelabel{$\x{com}$}] Afferma che la comunicazione fra due istanza di
 processo può avvenire solo se si realizza il matching, in rispetto dello stato
 di correlazione, dei valori del messaggio con le variabili di ricezione.
 Ovviamente ci deve essere anche uguaglianza sintattica fra i partener link e
 il nome dell'operazione. Tale regola afferma anche che fra tutte le istanze
 con un'attività di ricezione attiva conforme con i partenr link e l'operazione
 del messaggio in arrivo, si ne debba segliere una con grado di
 definizione minimo.
 \item[\rulelabel{$\x{new}$}] Descrive la creazione di una nuova istanza di
 processo a partire dalla definizione $\xproc{\xsa}{\xh_f}$ a seguito
 dell'arrivo di un messaggio $\talpha_2 =
  \xapp{\tilde{\xp}}{\xapp{\xo}{\bar{\xv}}}$ che risulti in matching con una delle start activity della
 definizione stessa. Ancora una volta la nuova istanza verrà creata solo se non
 ci sia già una istanza capace di ricevere il messaggio con un grado di
 definizione minore della start activity.
 \item[\rulelabel{$\x{var}$}] Afferma quanto già precedentemente detto che
 l'assegnamento di un valore $\xv$ ad una variabile $\xx$ del correlation set
 su uno stato $\xsigma$ possa avvenire solo se $ \xx \notin dom(\xsigma)$ o se $
 \updat{\xx}{\xv} \in \xsigma$.
 \item[\rulelabel{$\x{part}$} \rulelabel{$\x{pass}$} \rulelabel{$\x{cong}$}]
 Tali regole risultano particolarmente ovvie ed esprimono rispettivamente
 l'evoluzione parallela di un sistema di deployment, l'esecuzione
 indipendente delle operazioni interne in ciascuna istanza, l'uguaglianze delle
 riduzioni di deployment strutturalmente congruenti.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SINTASSI CONCRETA
\section{Una grammatica per un compilatore 
%(??o Parser??)
}

Il primo passo per lo sviluppo di un motore di esecuzione per Blite è la
realizzazione di un parser per l'analisi di programmi ottenibili dalla sintassi
presentata in Tabella \ref{tab:syntaxwsbpel}. Un parser è il software predisposto
alla realizzazione dell'\emph{Analisi Sintattica}, cioè del procedimento che
riconosce la struttura del programma sorgente e ne construisce l'\emph{Albero
Sintattico} (\emph{Abstract Sintatic Tree - AST}) associato. Come già osservato
la sintasi esposta, pur specificando in modo formale i termini del linguaggio,
non si presta ad essere implementata direttamente, in quanto per esempio
presenta produzioni del tipo 
$$
\begin{array}{rcl}
\xs & ::= &
\xs \xsucc\xs  \!\sepgr\! \xs \xpar \xs 
\end{array}
$$
che la rendano ambigua, per cui ad una frase del linguaggio può corrispondere
più di una albero sintattico. Riulta chiaro quindi che il primo obiettivo sarà
quello di ottenere una grammatica direttamente implemetabile 
dal cui linguaggio sia possibile ottenere i programmi Blite.
\\

Dalla teoria dei linguaggi sappiamo che le grammatiche per generare linguaggi
analizzabili con parser deterministici, cioè che non fanno uso di tecniche di
backtraking, sono raggrupabili in sotto classi specifiche fra tutte le possibili
grammatiche context free. In particolar modo risultano fondamentali per
realizzazione di analizzatori sintattici le seguenti classi di grammatiche:
\begin{itemize}
  \item \textbf{LL(k)}: Per cui risulta possibile realizzare parser top-down
  deterministici che utilizzano al più $k$ simboli non ancora riconosciuti
  della frase di input.
  \item \textbf{LR(k)}: Per cui risulta possibile realizzare parser bottom-up
  deterministici che utilizzano al più $k$ simboli non ancora riconosciuti
  della frase di input.
\end{itemize}

I parser top-down construisco l'albero sintattico dalla radice (simbolo
iniziale della grammatica) alle foglie (simboli terminali della frase di
input) secondo la derivazione canonica sinistra, mentre quelli bottom-up
realizzano l'albero sintattico dalle foglie alla radice seguendo la riduzione
destra. 

La derivazione è quel processo che a partire dal simbolo iniziale della
grammatica $S$ arriva alla frase di input applicando ad ogni passo una
sostituzione di un simbolo non terminale $X$ con una parte destra $Y$ presente in
una regola $X ::= Y$ della grammatica. 

Una derivazione può essere scritta come $$ S \Rightarrow \cdots \Rightarrow
abcX\ldots \Rightarrow abcY\ldots \cdots \Rightarrow abcdeZ\ldots \Rightarrow
\cdots \Rightarrow abcdef\ldots mn $$ in cui l'ultima stringa è formata solo da
terminali. Con i simboli $ \Rightarrow^*$ si intendono zero o più passi
successivi e con $\Rightarrow^+$ uno o più passi successivi. I singoli passi
della derivazione legano forme di frasi (strighe $s \in V^*$ composte da
terminali e non terminali ) ammesse dalla grammatica. In una analisi top-down si
realizza la derivazione canonica sinistra, cioè si sceglie di sostituire il primo
simbolo non terminale che compare più a sinistra nella forma di frase corrente.
Quindi la forma di frase corrente avrà sempre una forma $aXw$ con $a \in VT^*$
($VT$ insieme dei simboli terminali del linguaggio), $X$ simbolo non terminale
corrente, $w \in V^*$ ($V$ insieme dei simboli terminali e non terminali della
grammatica) e la stringa $a$ constituirà un prefisso della frase di input e
indicherà la parte di essa già riconosciuta. Alternativamente alla derivazione
canonica sinistra si definisce la derivazione canonica destra che sceglie di
sostituire il primo simbolo non terminale che compare più a destra nella forma di
frase corrente. L'analisi bottom-up reallizza la riduzione destra che è la
sequenza inversa della derivazione canonica destra.

In generale con le grammatiche LR si riesce a rappresentare un numero
maggiore di linguaggi rispetto alle grammatiche LL, cioè l'insieme dei
linguaggi generati con grammatiche LL è contenuto nell'insieme dei linguaggi
generati con grammatic LR, con quest'ultime però risulta molto più complessa la
realizzazione dei parser in quanto è necessario implemetare algortmi e
strutture dati più raffinati.

Inoltre le grammatiche LL hanno caratteristiche più facilmente individuabili,
di fatto da una generica grammatica come può essere quella di Tabella
\ref{tab:syntaxwsbpel} si può ottenere con molta probabilità\footnote{Per una
tratazione più formale riguardo al riconoscimento di grammatiche LL(k) si
rimanda ai testi , come [Bruno] e [DragonBook]} un grammatica LL applicanto i
seguenti semplici passi:
\begin{itemize}
  \item Eliminazione della ricorsione sinistra. Una grammatica che presenta
  regole 
  \item Fattorizzazione sinistra
\end{itemize}

Nel momento in cui ci si trovi a dover realizzare un parser le strade da poter
percorrere sono fondamentalmente due: munirsi di un buon background teorico
implemetare . Di fatto si è scelto la seconda strada anche per l'ampia di
disponibilità di tool (anche open source) e l'ottimo livello di affidabilità e funzionalità offerto.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SEMATICA CONCRETA
\section{Alcune osservazioni sulla sematica della correlazione}
